:hardbreaks-option:

= Collect Rack

image::https://build.opensuse.org/projects/home:Levitating/packages/collectrack/badge.svg?repository=openSUSE_Factory&architecture=x86_64[build result, link="https://build.opensuse.org/package/show/home:Levitating/collectrack"]

Collect Rack is a web frontend for graphing https://oss.oetiker.ch/rrdtool/[.rrd] files generated by https://www.collectd.org/[collectd].

Before Collect Rack I made https://github.com/LevitatingBusinessMan/rrd2html.rb[rrd2html.rb] which is a very minimal (you could say code golfed) CGI application.
This project was born out of dissatisfaction with https://github.com/LevitatingBusinessMan/rrd2html.rb[rrd2html.rb] and inspired by https://github.com/pommi/CGP[pommi/CGP].

The "Collect" part of the name refers to https://www.collectd.org/[collectd]. The "Rack" part for it being a https://github.com/rack/rack/blob/main/SPEC.rdoc[Rack] app.

[cols="1,1"]
|===
| Web Framework
| https://sinatrarb.com/[Sinatra]

| Templating Engine
| https://slim-template.github.io/[Slim]

| Gateway Interface
| https://github.com/rack/rack/blob/main/SPEC.rdoc[Rack]

| Server
| https://puma.io/[Puma] or other https://github.com/rack/rack/tree/main?tab=readme-ov-file#supported-web-servers[Rack::Handler]

| Graphing
| https://oss.oetiker.ch/rrdtool/[rrdtool]

| Data Collection
| https://collectd.org[collectd]
|===

== Features
Collect Rack aims to be significantly faster than existing web frontends for collectd.
Requests to render graphs are sent out in parallel to the application.
The application then interacts with the official Ruby bindings of `librrd` instead of spawning a process, and the output is streamed through a pipe directly to the underlying webserver.
When rendering many graphs Collect Track has about twice the speed of CGP.

It can also utilize the https://www.collectd.org/documentation/manpages/collectd-unixsock.html[unixsock] plugin to flush the caches of the plugins its graphing.
This means that your graphs will always be up-to-date even with a large `CacheTimeout` setting.


CollectTrack can parse your existing `collectd.conf` file to draw configuration values from.
This is used to get values like your `BaseDir` and `unixsock` socket file.

== Running

After running `bundle install`, the app can be started using `bin/rackup`, `bin/puma` or `ruby src/app.rb`. Whatever you prefer.

There is also a https://build.opensuse.org/package/show/home:Levitating/collectrack[package] available for OpenSUSE.

== Configuration
Collect Rack uses the same syntax as `collectd.conf` and by default it searches for your existing `/etc/collectd.conf`.

If you want to use a config file that is not `/etc/collectd.conf` you can specify it using the `COLLECTD_CONFIG` environment variable.

For options specific to `CollectTrack` you can use a block called `CollectTrack`.

An example config could look like this:

```
BaseDir "/var/lib/collectd"

<CollectTrack>
  PluginConfDir "/opt/collectrack/plugins"
  FlushSocket   true
</CollectTrack>

<Plugin unixsock>
  SocketFile "/run/collectd.sock"
</Plugin>

```

Options for the `CollectTrack` block are:

* `PluginConfDir`: Where to draw `.yaml` plugin configurations from. Default `./plugins`.
* `FlushSocket`: Flush the collectd cache when drawing graphs. The `unixsock` plugin must be configured for this to work. Default `true`.

==== Development

There is a development script `src/rerun.rb` which listens to sourcecode changes and restarts the puma server.

This script can be executed with `ruby src/rerun.rb` or `bin/rerun`.
It will execute `puma -e development` by default, other commands to start the server can be specified on the command line.
However using `rackup` causes the  host and port to reset after a restart.

```
bin/rerun
```

== Default plugin behavior
Collect Rack ships aims to ship with instructions to graph most popular collectd plugins (see `./plugins`).
However I cannot configure all plugins for all environments and some plugins are inherently unpredictable.
So there is a default behavior for graphing unknown databases.

This default behavior is to draw a separate graph for each .rrd file found in a plugin instance.
A line is then drawn for each ds in the database.

This doesn't work well for some plugins like `memory` or `cpu` which have multiple data sources saved as ds `value` across multiple databases.
For these a single graph with data across all databases would be preferred.

However most plugins store different units in different files.
So for most other plugins the current behavior produces good graphs, even for generally unconfigurable plugins like `sensor`.
