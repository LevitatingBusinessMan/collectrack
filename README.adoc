:hardbreaks-option:

= Collect Rack

Collect Rack is a graphing frontend for https://oss.oetiker.ch/rrdtool/[.rrd] files generated by https://www.collectd.org/[collectd]

Before Collect Rack I made https://github.com/LevitatingBusinessMan/rrd2html.rb[rrd2html.rb] which is a very minimal (you could say code golfed) CGI application.
This project was born out of dissatisfaction with https://github.com/LevitatingBusinessMan/rrd2html.rb[rrd2html.rb] and inspired by https://github.com/pommi/CGP[pommi/CGP].

The "Collect" part of the name refers to collectd. The "Rack" part for that fact that it is a https://github.com/rack/rack/blob/main/SPEC.rdoc[Rack] app.

== Running

The app can be started using `rackup`, `puma` or by sinatra itself via `ruby ./src/app.rb`.

==== Development

When starting puma in development it is configured open a unix socket for `pumactl`.

There is a development script `src/rerun.rb` which listens to sourcecode changes and restarts the puma server.
This can be executed with `ruby src/rerun.rb` or `bin/rerun`.
This script will execute `puma -C config/puma.rb` by default when no running puma is detected.
Other commands to start the server can be specified on the command line, but using `rackup` causes the host and port to reset after a restart.

```
bin/rerun
```

== Default behavior
Collect Rack ships aims to ship with instruction to draw most popular collectd plugins.
However I cannot configure all plugins for all environments and some plugins are inherently unpredictable.
So there is a default behavior for graphing unknown databases.

This default behavior is to draw a separate graph for each .rrd file found in a plugin instance.
A line is then drawn for each ds in the database.

This doesn't work well for some plugins like `memory` or `cpu` which have multiple data sources saved as ds `value` across multiple databases.
For these a single graph for data across all databases would be preferred, and this is the old default behavior.

However most plugins store different units in different files.
So for most other plugins the current behavior produces good graphs, even for unconfigurable plugins like `sensor`.
